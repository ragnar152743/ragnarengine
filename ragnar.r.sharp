\
# RagnarEngine Python V3 (from scratch)
# Focus V3: "real clickable buttons for everything" + "buttons instead of keys"
# deps: pygame  -> pip install pygame
# run:
#   python ragnarengine.py --editor <project>
#   python ragnarengine.py --game <project>

from __future__ import annotations
import argparse, json, math, os
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Tuple
import pygame

# ---------- utils ----------
def clamp(v,a,b): return a if v<a else b if v>b else v
def jload(p, d):
    try: return json.loads(open(p,"r",encoding="utf-8").read())
    except Exception: return d
def jsave(p, o):
    with open(p,"w",encoding="utf-8") as f: json.dump(o,f,indent=2)

# ---------- math ----------
@dataclass
class V3: x: float; y: float; z: float
def rx(v:V3,a): c,s=math.cos(a),math.sin(a); return V3(v.x, v.y*c-v.z*s, v.y*s+v.z*c)
def ry(v:V3,a): c,s=math.cos(a),math.sin(a); return V3(v.x*c+v.z*s, v.y, -v.x*s+v.z*c)
def rz(v:V3,a): c,s=math.cos(a),math.sin(a); return V3(v.x*c-v.y*s, v.x*s+v.y*c, v.z)
def add(a:V3,b:V3): return V3(a.x+b.x,a.y+b.y,a.z+b.z)
def sub(a:V3,b:V3): return V3(a.x-b.x,a.y-b.y,a.z-b.z)
def dot(a:V3,b:V3): return a.x*b.x+a.y*b.y+a.z*b.z
def cross(a:V3,b:V3): return V3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x)
def norm(a:V3):
    l=math.sqrt(dot(a,a)) or 1.0
    return V3(a.x/l,a.y/l,a.z/l)

# ---------- scene ----------
@dataclass
class Ent:
    id:int
    name:str
    pos:V3=field(default_factory=lambda:V3(0,0,0))
    rot:V3=field(default_factory=lambda:V3(0,0,0))
    scl:V3=field(default_factory=lambda:V3(1,1,1))
    mesh:str="cube"
    comp:Dict[str,Any]=field(default_factory=dict)

@dataclass
class Scene:
    name:str="Scene"
    ents:List[Ent]=field(default_factory=list)
    sel:Optional[int]=None

def load_scene(p:str)->Scene:
    d=jload(p, {"name":"Scene","ents":[]})
    s=Scene(d.get("name","Scene"))
    s.sel=d.get("sel")
    for e in d.get("ents",[]):
        s.ents.append(Ent(
            int(e.get("id",0)), e.get("name","Ent"),
            V3(*e.get("pos",[0,0,0])),
            V3(*e.get("rot",[0,0,0])),
            V3(*e.get("scl",[1,1,1])),
            e.get("mesh","cube"),
            e.get("comp",{}) or {}
        ))
    return s

def save_scene(s:Scene,p:str):
    jsave(p, {
        "name": s.name,
        "sel": s.sel,
        "ents": [{
            "id":e.id,"name":e.name,
            "pos":[e.pos.x,e.pos.y,e.pos.z],
            "rot":[e.rot.x,e.rot.y,e.rot.z],
            "scl":[e.scl.x,e.scl.y,e.scl.z],
            "mesh":e.mesh,
            "comp":e.comp
        } for e in s.ents]
    })

# ---------- project ----------
DEFAULT_PROJECT = {
  "name":"MyGame",
  "main_scene":"scene.json",
  "render":{"mode":"FILL","fov":75.0},
  "input":{
    "layout":"AUTO",     # AUTO/AZERTY/QWERTY
    "mode":"BOTH",       # KEYBOARD/BUTTONS/BOTH
    "bindings":{"Forward":"W","Back":"S","Left":"A","Right":"D","Up":"SPACE","Down":"LCTRL"}
  },
  "ui":{"virtual_buttons":True}
}
AZ={"Forward":"Z","Back":"S","Left":"Q","Right":"D"}
QW={"Forward":"W","Back":"S","Left":"A","Right":"D"}
def guess_layout():
    import locale
    loc=((locale.getdefaultlocale() or ("",""))[0] or "").lower()
    return "AZERTY" if "fr" in loc else "QWERTY"

def build_bind(project)->Dict[str,int]:
    inp=project.get("input",{})
    layout=(inp.get("layout","AUTO") or "AUTO").upper()
    bind=dict(inp.get("bindings",{}) or {})
    if layout=="AUTO": layout=guess_layout()
    if layout=="AZERTY":
        for k,v in AZ.items(): bind.setdefault(k,v)
    elif layout=="QWERTY":
        for k,v in QW.items(): bind.setdefault(k,v)
    out={}
    for act, keyname in bind.items():
        try: out[act]=pygame.key.key_code(keyname.lower())
        except Exception:
            try: out[act]=pygame.key.key_code(keyname)
            except Exception: out[act]=pygame.K_UNKNOWN
    return out

# ---------- mesh ----------
CUBE_V=[V3(-1,-1,-1),V3(1,-1,-1),V3(1,1,-1),V3(-1,1,-1),V3(-1,-1,1),V3(1,-1,1),V3(1,1,1),V3(-1,1,1)]
CUBE_E=[(0,1),(1,2),(2,3),(3,0),(4,5),(5,6),(6,7),(7,4),(0,4),(1,5),(2,6),(3,7)]
CUBE_T=[(0,1,2),(0,2,3),(4,6,5),(4,7,6),(0,4,5),(0,5,1),(1,5,6),(1,6,2),(2,6,7),(2,7,3),(3,7,4),(3,4,0)]

# ---------- camera + projection ----------
@dataclass
class Cam:
    pos:V3=field(default_factory=lambda:V3(0,1.2,6))
    yaw:float=math.pi
    pit:float=0.0

def w2c(p:V3,c:Cam)->V3:
    v=sub(p,c.pos)
    v=ry(v,-c.yaw)
    v=rx(v,-c.pit)
    return v

def proj(v:V3,w:int,h:int,fov:float)->Optional[Tuple[int,int,float]]:
    if v.z<=0.05: return None
    f=(w/2)/math.tan(math.radians(fov)/2)
    return (int(w/2+(v.x*f)/v.z), int(h/2-(v.y*f)/v.z), v.z)

def ent_verts(e:Ent)->List[V3]:
    out=[]
    for v in CUBE_V:
        vv=V3(v.x*e.scl.x, v.y*e.scl.y, v.z*e.scl.z)
        vv=rz(vv,e.rot.z); vv=ry(vv,e.rot.y); vv=rx(vv,e.rot.x)
        out.append(add(vv,e.pos))
    return out

# ---------- fill raster ----------
def edge(a,b,c): return (c[0]-a[0])*(b[1]-a[1]) - (c[1]-a[1])*(b[0]-a[0])
def tri_bbox(p0,p1,p2,w,h):
    return (max(0,min(p0[0],p1[0],p2[0])), max(0,min(p0[1],p1[1],p2[1])),
            min(w-1,max(p0[0],p1[0],p2[0])), min(h-1,max(p0[1],p1[1],p2[1])))

def tri_fill(surf, zbuf, p0,p1,p2, col):
    w,h=surf.get_width(), surf.get_height()
    minx,miny,maxx,maxy=tri_bbox(p0,p1,p2,w,h)
    A=edge(p0,p1,p2)
    if A==0: return
    inv=1.0/A
    for y in range(miny,maxy+1):
        for x in range(minx,maxx+1):
            p=(x,y)
            w0=edge(p1,p2,p)*inv; w1=edge(p2,p0,p)*inv; w2=edge(p0,p1,p)*inv
            if w0>=0 and w1>=0 and w2>=0:
                z=w0*p0[2]+w1*p1[2]+w2*p2[2]
                i=y*w+x
                if z<zbuf[i]:
                    zbuf[i]=z
                    surf.set_at((x,y), col)

def draw_ent(surf, cam:Cam, e:Ent, fov:float, mode:str, col):
    w,h=surf.get_width(), surf.get_height()
    Vw=ent_verts(e)
    pts=[proj(w2c(v,cam), w,h,fov) for v in Vw]
    if mode=="FILL":
        zbuf=[1e9]*(w*h)
        light=norm(V3(-0.4,0.8,-0.3))
        for a,b,c in CUBE_T:
            p0,p1,p2=pts[a],pts[b],pts[c]
            if not p0 or not p1 or not p2: continue
            n=norm(cross(sub(Vw[b],Vw[a]), sub(Vw[c],Vw[a])))
            nd=max(0.15, dot(n, light))
            cc=(int(col[0]*nd),int(col[1]*nd),int(col[2]*nd))
            tri_fill(surf,zbuf,p0,p1,p2,cc)
        # outline
        for a,b in CUBE_E:
            p0,p1=pts[a],pts[b]
            if p0 and p1:
                pygame.draw.line(surf,(10,10,10),(p0[0],p0[1]),(p1[0],p1[1]),2)
    else:
        for a,b in CUBE_E:
            p0,p1=pts[a],pts[b]
            if p0 and p1:
                pygame.draw.line(surf,col,(p0[0],p0[1]),(p1[0],p1[1]),2)

# ---------- UI ----------
def font(sz): return pygame.font.SysFont("consolas", sz)

def label(surf,x,y,t,sz=16,c=(230,230,240)):
    surf.blit(font(sz).render(t,True,c),(x,y))

def button(surf, r, t, mouse, click):
    r=pygame.Rect(r)
    hov=r.collidepoint(mouse)
    bg=(55,55,72) if not hov else (90,90,120)
    pygame.draw.rect(surf,bg,r,border_radius=10)
    pygame.draw.rect(surf,(170,170,215),r,2,border_radius=10)
    txt=font(16).render(t,True,(245,245,255))
    surf.blit(txt,(r.x+10, r.y+(r.h-txt.get_height())//2))
    return hov and click

# ---------- Virtual buttons (game) ----------
class VButtons:
    def __init__(self, w,h):
        self.w=w; self.h=h
        self.down:Dict[str,bool]={}
        s=58; g=10
        x=20; y=h-200
        self.btn=[
            ("Left",   pygame.Rect(x, y+s+g, s,s), "◀"),
            ("Right",  pygame.Rect(x+(s+g)*2, y+s+g, s,s), "▶"),
            ("Forward",pygame.Rect(x+(s+g), y, s,s), "▲"),
            ("Back",   pygame.Rect(x+(s+g), y+(s+g)*2, s,s), "▼"),
            ("Up",     pygame.Rect(w-s-20, y, s,s), "UP"),
            ("Down",   pygame.Rect(w-s-20, y+s+g, s,s), "DN"),
            ("Pause",  pygame.Rect(w-130, 20, 110,44), "Pause"),
        ]

    def begin(self): self.down={}
    def draw(self, surf, mouse, held):
        f=font(18)
        for act, r, txts in self.btn:
            hov=r.collidepoint(mouse)
            bg=(40,40,55) if not hov else (80,80,115)
            pygame.draw.rect(surf,bg,r,border_radius=12)
            pygame.draw.rect(surf,(160,160,210),r,2,border_radius=12)
            t=f.render(txts,True,(245,245,255))
            surf.blit(t,(r.centerx-t.get_width()//2, r.centery-t.get_height()//2))
            if hov and held:
                self.down[act]=True

# ---------- R# (tiny) ----------
# supports:
# let speed = 2.5;
# if (key("Forward")) { move("Player", 0, 0, -speed*dt); }
# rotY("Cube", 60*dt);
def tok(s:str):
    out=[]; i=0
    while i<len(s):
        c=s[i]
        if c.isspace(): i+=1
        elif c in "+-*/()": out.append(c); i+=1
        elif c.isdigit() or c==".": 
            j=i
            while j<len(s) and (s[j].isdigit() or s[j]=="."): j+=1
            out.append(s[i:j]); i=j
        elif c.isalpha() or c=="_":
            j=i
            while j<len(s) and (s[j].isalnum() or s[j]=="_"): j+=1
            out.append(s[i:j]); i=j
        else: i+=1
    return out

def expr(tokens, vars):
    prec={"+":1,"-":1,"*":2,"/":2}
    out=[]; op=[]
    for t in tokens:
        if t.replace(".","",1).isdigit(): out.append(float(t))
        elif t in prec:
            while op and op[-1] in prec and prec[op[-1]]>=prec[t]:
                out.append(op.pop())
            op.append(t)
        elif t=="(": op.append(t)
        elif t==")":
            while op and op[-1]!="(":
                out.append(op.pop())
            if op and op[-1]=="(": op.pop()
        else: out.append(("v",t))
    while op: out.append(op.pop())
    st=[]
    for it in out:
        if isinstance(it,float): st.append(it)
        elif isinstance(it,tuple): st.append(float(vars.get(it[1],0.0)))
        else:
            b=st.pop() if st else 0.0
            a=st.pop() if st else 0.0
            if it=="+": st.append(a+b)
            elif it=="-": st.append(a-b)
            elif it=="*": st.append(a*b)
            elif it=="/": st.append(a/b if b else 0.0)
    return st[-1] if st else 0.0

def argsplit(s):
    a=[]; cur=""; d=0; ins=False
    for i,c in enumerate(s):
        if c=='"' and (i==0 or s[i-1]!="\\"): ins=not ins; cur+=c
        elif not ins:
            if c=="(": d+=1; cur+=c
            elif c==")": d-=1; cur+=c
            elif c=="," and d==0: a.append(cur.strip()); cur=""
            else: cur+=c
        else: cur+=c
    if cur.strip(): a.append(cur.strip())
    return a

def val(v, vars):
    v=v.strip()
    if v.startswith('"') and v.endswith('"'): return v[1:-1]
    if v.replace(".","",1).isdigit(): return float(v)
    return expr(tok(v), vars)

def rsharp_run(script:str, scene:Scene, action_down, dt:float):
    vars={"dt":float(dt)}
    def get(name): 
        for e in scene.ents:
            if e.name==name: return e
        return None

    # clean lines
    lines=[]
    for raw in script.splitlines():
        line=raw.strip()
        if not line or line.startswith("//"): continue
        if "//" in line: line=line.split("//",1)[0].strip()
        if line: lines.append(line)

    for line in lines:
        if line.startswith("let "):
            body=line[4:].rstrip(";").strip()
            if "=" in body:
                n,ex=body.split("=",1)
                vars[n.strip()]=float(val(ex,vars))
            continue
        if line.startswith("if"):
            try:
                l=line.index("("); r=line.rindex(")")
                cond=line[l+1:r].strip()
                ok=False
                if 'key("' in cond:
                    s=cond.index('key("')+5
                    e=cond.index('")',s)
                    act=cond[s:e]
                    ok = action_down(act)
                else:
                    ok = expr(tok(cond), vars)!=0.0
                if not ok: continue
                if "{" in line and "}" in line:
                    inner=line.split("{",1)[1].rsplit("}",1)[0].strip().rstrip(";")
                    line=inner
                else:
                    continue
            except Exception:
                continue

        call=line.rstrip(";")
        if call.startswith("move"):
            inside=call[call.index("(")+1:call.rindex(")")]
            a=argsplit(inside)
            if len(a)>=4:
                name=val(a[0],vars)
                dx=float(val(a[1],vars)); dy=float(val(a[2],vars)); dz=float(val(a[3],vars))
                if isinstance(name,str):
                    e=get(name)
                    if e: e.pos.x+=dx; e.pos.y+=dy; e.pos.z+=dz
            continue
        if call.startswith("rotY"):
            inside=call[call.index("(")+1:call.rindex(")")]
            a=argsplit(inside)
            if len(a)>=2:
                name=val(a[0],vars); deg=float(val(a[1],vars))
                if isinstance(name,str):
                    e=get(name)
                    if e: e.rot.y+=math.radians(deg)
            continue

# ---------- Code editor (mini) ----------
class CodeEdit:
    def __init__(self): 
        self.lines=[""]; self.x=0; self.y=0; self.path=None; self.dirty=False
    def load(self,p):
        self.path=p
        try: self.lines=open(p,"r",encoding="utf-8").read().splitlines() or [""]
        except Exception: self.lines=[""]
        self.x=0; self.y=0; self.dirty=False
    def save(self):
        if not self.path: return
        open(self.path,"w",encoding="utf-8").write("\n".join(self.lines)+("\n" if self.lines else ""))
        self.dirty=False
    def key(self,ev):
        if ev.key==pygame.K_BACKSPACE:
            if self.x>0:
                ln=self.lines[self.y]; self.lines[self.y]=ln[:self.x-1]+ln[self.x:]; self.x-=1; self.dirty=True
            elif self.y>0:
                prev=self.lines[self.y-1]; cur=self.lines[self.y]
                self.x=len(prev); self.lines[self.y-1]=prev+cur; self.lines.pop(self.y); self.y-=1; self.dirty=True
        elif ev.key==pygame.K_RETURN:
            ln=self.lines[self.y]; L,R=ln[:self.x], ln[self.x:]
            self.lines[self.y]=L; self.lines.insert(self.y+1,R); self.y+=1; self.x=0; self.dirty=True
        elif ev.key==pygame.K_TAB:
            self.ins("    ")
        elif ev.key==pygame.K_LEFT:
            if self.x>0: self.x-=1
            elif self.y>0: self.y-=1; self.x=len(self.lines[self.y])
        elif ev.key==pygame.K_RIGHT:
            if self.x<len(self.lines[self.y]): self.x+=1
            elif self.y<len(self.lines)-1: self.y+=1; self.x=0
        elif ev.key==pygame.K_UP:
            if self.y>0: self.y-=1; self.x=min(self.x,len(self.lines[self.y]))
        elif ev.key==pygame.K_DOWN:
            if self.y<len(self.lines)-1: self.y+=1; self.x=min(self.x,len(self.lines[self.y]))
        elif ev.unicode and ev.unicode.isprintable():
            self.ins(ev.unicode)
    def ins(self,s):
        ln=self.lines[self.y]
        self.lines[self.y]=ln[:self.x]+s+ln[self.x:]
        self.x+=len(s); self.dirty=True
    def draw(self,surf,rect):
        pygame.draw.rect(surf,(14,14,18),rect)
        pygame.draw.rect(surf,(90,90,115),rect,2)
        f=font(16); lh=18
        x0,y0=rect.x+10,rect.y+10
        maxl=(rect.h-30)//lh
        start=max(0,self.y-maxl//2); end=min(len(self.lines), start+maxl)
        for i in range(start,end):
            ln=self.lines[i]
            surf.blit(f.render(f"{i+1:03d} ",True,(120,120,145)), (x0,y0+(i-start)*lh))
            surf.blit(f.render(ln,True,(230,230,240)), (x0+45,y0+(i-start)*lh))
        if start<=self.y<end:
            pre=self.lines[self.y][:self.x]
            cx=x0+45+f.size(pre)[0]
            cy=y0+(self.y-start)*lh
            pygame.draw.rect(surf,(240,240,255),(cx,cy,2,lh-2))
        name=self.path or "(no file)"
        flag="*" if self.dirty else ""
        surf.blit(font(14).render(f"{name}{flag} | Ctrl+S save | F2 back",True,(200,200,215)), (rect.x+10, rect.bottom-20))

# ---------- EDITOR ----------
def run_editor(project_root="."):
    pygame.init(); pygame.font.init()
    prj_path=os.path.join(project_root,"project.json")
    prj=jload(prj_path, dict(DEFAULT_PROJECT))
    for k,v in DEFAULT_PROJECT.items(): prj.setdefault(k,v)
    prj.setdefault("render",{}); prj.setdefault("input",{}); prj.setdefault("ui",{})
    prj["render"].setdefault("mode","FILL"); prj["render"].setdefault("fov",75.0)
    prj["input"].setdefault("layout","AUTO"); prj["input"].setdefault("mode","BOTH"); prj["input"].setdefault("bindings", DEFAULT_PROJECT["input"]["bindings"])
    prj["ui"].setdefault("virtual_buttons", True)

    binds=build_bind(prj)
    scene_path=os.path.join(project_root, prj.get("main_scene","scene.json"))
    scene=load_scene(scene_path) if os.path.exists(scene_path) else Scene("Scene",[Ent(1,"Cube")],1)
    if scene.sel is None and scene.ents: scene.sel=scene.ents[0].id

    # ensure scripts + Player
    os.makedirs(os.path.join(project_root,"scripts"), exist_ok=True)
    script_path=os.path.join(project_root,"scripts","main.rsharp")
    if not os.path.exists(script_path):
        open(script_path,"w",encoding="utf-8").write(
            '// R# example\n'
            'let speed = 2.5;\n'
            'if (key("Forward")) { move("Player", 0, 0, -speed*dt); }\n'
            'if (key("Back")) { move("Player", 0, 0, speed*dt); }\n'
            'if (key("Left")) { move("Player", -speed*dt, 0, 0); }\n'
            'if (key("Right")) { move("Player", speed*dt, 0, 0); }\n'
            'rotY("Cube", 60*dt);\n'
        )
    if not any(e.name=="Player" for e in scene.ents):
        nid=max([e.id for e in scene.ents], default=0)+1
        scene.ents.append(Ent(nid,"Player",V3(0,1.0,3), comp={"Controller":{"speed":3.0},"Script":{"file":"scripts/main.rsharp"}}))
        scene.sel=nid

    cam=Cam()
    W,H=1280,720
    screen=pygame.display.set_mode((W,H))
    pygame.display.set_caption("RagnarEngine Editor V3")
    clock=pygame.time.Clock()
    show_code=False
    ed=CodeEdit(); ed.load(script_path)

    left=360
    def sel_ent():
        for e in scene.ents:
            if e.id==scene.sel: return e
        return None

    # editor state
    step=0.25

    running=True
    while running:
        dt=clock.tick(120)/1000.0
        fps=clock.get_fps()
        mouse=pygame.mouse.get_pos()
        click=False
        for ev in pygame.event.get():
            if ev.type==pygame.QUIT: running=False
            elif ev.type==pygame.MOUSEBUTTONDOWN and ev.button==1: click=True
            elif ev.type==pygame.KEYDOWN:
                if show_code:
                    if (ev.key==pygame.K_s) and (pygame.key.get_mods()&pygame.KMOD_CTRL): ed.save()
                    elif ev.key==pygame.K_F2: show_code=False
                    else: ed.key(ev)
                else:
                    if ev.key==pygame.K_ESCAPE: running=False
                    elif ev.key==pygame.K_F2: show_code=True
                    elif ev.key==pygame.K_F5:
                        prj["render"]["fov"]=float(prj["render"]["fov"])
                        jsave(prj_path, prj)
                        save_scene(scene, scene_path)

        screen.fill((10,10,14))
        if show_code:
            ed.draw(screen, pygame.Rect(10,10,W-20,H-20))
            pygame.display.flip()
            continue

        # viewport
        vp=pygame.Rect(left,0,W-left,H)
        pygame.draw.rect(screen,(18,18,24),vp)
        vps=screen.subsurface(vp)
        vps.fill((16,16,22))

        mode=(prj["render"]["mode"] or "FILL").upper()
        fov=float(prj["render"]["fov"])
        for e in scene.ents:
            col=(255,210,90) if e.id==scene.sel else (80,200,255)
            draw_ent(vps, cam, e, fov, mode, col)

        # left panel
        pygame.draw.rect(screen,(20,20,28),(0,0,left,H))
        label(screen,12,12,f"Editor V3 | FPS {fps:5.1f}",16)
        label(screen,12,34,"Everything = buttons. Keys optional.",14,(200,200,215))

        y=60
        if button(screen,(12,y,left-24,40),"SAVE",mouse,click):
            jsave(prj_path, prj); save_scene(scene, scene_path)
        y+=48
        if button(screen,(12,y,left-24,40),"CODE EDITOR (F2)",mouse,click):
            show_code=True
        y+=48
        if button(screen,(12,y,left-24,40),"ADD CUBE",mouse,click):
            nid=max([e.id for e in scene.ents], default=0)+1
            scene.ents.append(Ent(nid,f"Cube{nid}",V3(0,0,0)))
            scene.sel=nid
        y+=48
        if button(screen,(12,y,left-24,40),"DELETE SELECTED",mouse,click):
            if scene.sel is not None:
                scene.ents=[e for e in scene.ents if e.id!=scene.sel]
                scene.sel=scene.ents[0].id if scene.ents else None
        y+=56

        # render/layout/mode
        if button(screen,(12,y,left-24,40),f"RENDER: {mode} (toggle)",mouse,click):
            prj["render"]["mode"]="WIRE" if mode=="FILL" else "FILL"
        y+=48
        layout=(prj["input"]["layout"] or "AUTO").upper()
        if button(screen,(12,y,left-24,40),f"KEYBOARD: {layout} (cycle)",mouse,click):
            prj["input"]["layout"]={"AUTO":"AZERTY","AZERTY":"QWERTY","QWERTY":"AUTO"}[layout]
            binds=build_bind(prj)
        y+=48
        imode=(prj["input"]["mode"] or "BOTH").upper()
        if button(screen,(12,y,left-24,40),f"INPUT MODE: {imode} (cycle)",mouse,click):
            prj["input"]["mode"]={"BOTH":"KEYBOARD","KEYBOARD":"BUTTONS","BUTTONS":"BOTH"}[imode]
        y+=56

        # FOV buttons
        label(screen,12,y,"FOV:",14); 
        if button(screen,(70,y-6,56,34),"-",mouse,click): prj["render"]["fov"]=clamp(float(prj["render"]["fov"])-2,40,110)
        if button(screen,(130,y-6,56,34),"+",mouse,click): prj["render"]["fov"]=clamp(float(prj["render"]["fov"])+2,40,110)
        label(screen,200,y,f"{float(prj['render']['fov']):.0f}",14,(255,230,160))
        y+=46

        # Step buttons
        label(screen,12,y,"STEP:",14)
        for i,sv in enumerate([0.1,0.25,0.5,1.0]):
            if button(screen,(70+i*72,y-6,64,34),str(sv),mouse,click):
                step=float(sv)
        label(screen,12,y+30,f"Current step: {step}",13,(200,200,215))
        y+=64

        # Transform controls (move/rot/scale/cam) - ALL BUTTONS
        label(screen,12,y,"TRANSFORM (selected):",14); y+=22
        e=sel_ent()
        def tr(lbl,x,y2):
            return button(screen,(x,y2,78,36),lbl,mouse,click)

        if e:
            x0=12; y0=y
            # Move
            if tr("X-",x0,y0): e.pos.x-=step
            if tr("X+",x0+84,y0): e.pos.x+=step
            if tr("Y-",x0+168,y0): e.pos.y-=step
            if tr("Y+",x0+252,y0): e.pos.y+=step
            y0+=42
            if tr("Z-",x0,y0): e.pos.z-=step
            if tr("Z+",x0+84,y0): e.pos.z+=step
            if tr("RY-",x0+168,y0): e.rot.y+=math.radians(-30*step)
            if tr("RY+",x0+252,y0): e.rot.y+=math.radians(30*step)
            y0+=42
            if tr("S-",x0,y0):
                e.scl.x=max(0.05,e.scl.x-0.25*step); e.scl.y=max(0.05,e.scl.y-0.25*step); e.scl.z=max(0.05,e.scl.z-0.25*step)
            if tr("S+",x0+84,y0):
                e.scl.x+=0.25*step; e.scl.y+=0.25*step; e.scl.z+=0.25*step
            if tr("Cam-",x0+168,y0): cam.pos.z+=1.0*step
            if tr("Cam+",x0+252,y0): cam.pos.z-=1.0*step
            y=y0+48
            label(screen,12,y,f"Pos {e.pos.x:.2f} {e.pos.y:.2f} {e.pos.z:.2f}",13,(200,200,215)); y+=18
            label(screen,12,y,f"RotY {math.degrees(e.rot.y):.0f}° | Scale {e.scl.x:.2f}",13,(200,200,215)); y+=18
        else:
            label(screen,12,y,"No selection.",13,(200,200,215)); y+=40

        # Hierarchy (buttons for select)
        y=min(640,y+10)
        label(screen,12,y,"HIERARCHY:",14); y+=22
        for ent in scene.ents[:6]:
            if button(screen,(12,y,left-24,34),f"[{ent.id}] {ent.name}",mouse,click):
                scene.sel=ent.id
            y+=40

        # (keep arrow keys too, just in case)
        k=pygame.key.get_pressed()
        e=sel_ent()
        if e:
            sp=3.0*dt
            if k[pygame.K_LEFT]: e.pos.x-=sp
            if k[pygame.K_RIGHT]: e.pos.x+=sp
            if k[pygame.K_UP]: e.pos.z-=sp
            if k[pygame.K_DOWN]: e.pos.z+=sp
            if k[pygame.K_PAGEUP]: e.pos.y+=sp
            if k[pygame.K_PAGEDOWN]: e.pos.y-=sp

        pygame.display.flip()

    pygame.quit()

# ---------- GAME ----------
def run_game(project_root="."):
    pygame.init(); pygame.font.init()
    prj=jload(os.path.join(project_root,"project.json"), dict(DEFAULT_PROJECT))
    for k,v in DEFAULT_PROJECT.items(): prj.setdefault(k,v)
    prj.setdefault("render",{}); prj.setdefault("input",{}); prj.setdefault("ui",{})
    prj["render"].setdefault("mode","FILL"); prj["render"].setdefault("fov",75.0)
    prj["input"].setdefault("layout","AUTO"); prj["input"].setdefault("mode","BOTH"); prj["input"].setdefault("bindings", DEFAULT_PROJECT["input"]["bindings"])
    prj["ui"].setdefault("virtual_buttons", True)

    binds=build_bind(prj)
    scene_path=os.path.join(project_root, prj.get("main_scene","scene.json"))
    scene=load_scene(scene_path) if os.path.exists(scene_path) else Scene("Scene",[Ent(1,"Cube")],1)

    cam=Cam()
    W,H=1100,700
    screen=pygame.display.set_mode((W,H))
    pygame.display.set_caption("RagnarEngine Game V3")
    clock=pygame.time.Clock()

    vbtn=VButtons(W,H)
    paused=False

    # scripts cache
    cache={}
    def script_text(rel):
        rel=rel.replace("\\","/")
        if rel in cache: return cache[rel]
        p=os.path.join(project_root, rel)
        try: t=open(p,"r",encoding="utf-8").read()
        except Exception: t=""
        cache[rel]=t
        return t

    def action_down(act:str)->bool:
        mode=(prj["input"].get("mode","BOTH") or "BOTH").upper()
        keys=pygame.key.get_pressed()
        kb=False
        kk=binds.get(act, pygame.K_UNKNOWN)
        if kk!=pygame.K_UNKNOWN: kb=keys[kk]
        vb=vbtn.down.get(act, False)
        if mode=="KEYBOARD": return kb
        if mode=="BUTTONS": return vb
        return kb or vb

    def controller(dt:float):
        pl=next((e for e in scene.ents if e.name=="Player"), None)
        if not pl: return
        sp=float(pl.comp.get("Controller",{}).get("speed",3.0)) if isinstance(pl.comp.get("Controller"), dict) else 3.0
        dx=dz=dy=0.0
        if action_down("Forward"): dz-=sp*dt
        if action_down("Back"): dz+=sp*dt
        if action_down("Left"): dx-=sp*dt
        if action_down("Right"): dx+=sp*dt
        if action_down("Up"): dy+=sp*dt
        if action_down("Down"): dy-=sp*dt
        pl.pos.x+=dx; pl.pos.y+=dy; pl.pos.z+=dz

    running=True
    while running:
        dt=clock.tick(120)/1000.0
        fps=clock.get_fps()
        mouse=pygame.mouse.get_pos()
        click=False
        held=pygame.mouse.get_pressed()[0]

        for ev in pygame.event.get():
            if ev.type==pygame.QUIT: running=False
            elif ev.type==pygame.MOUSEBUTTONDOWN and ev.button==1: click=True
            elif ev.type==pygame.KEYDOWN and ev.key==pygame.K_ESCAPE: running=False

        vbtn.begin()
        if prj["ui"].get("virtual_buttons", True):
            vbtn.draw(screen, mouse, held)

        if click and vbtn.down.get("Pause", False):
            paused=not paused

        if not paused:
            controller(dt)
            # scripts
            for e in scene.ents:
                sc=e.comp.get("Script")
                if isinstance(sc, dict) and sc.get("file"):
                    txt=script_text(sc["file"])
                    if txt:
                        rsharp_run(txt, scene, action_down, dt)

        screen.fill((10,10,14))
        mode=(prj["render"].get("mode","FILL") or "FILL").upper()
        fov=float(prj["render"].get("fov",75.0))
        for e in scene.ents:
            draw_ent(screen, cam, e, fov, mode, (80,200,255))

        if prj["ui"].get("virtual_buttons", True):
            vbtn.draw(screen, mouse, held)

        label(screen,10,10,f"FPS {fps:5.1f} | Mode {prj['input'].get('mode','BOTH')} | Layout {prj['input'].get('layout','AUTO')}",14)
        label(screen,10,30,"You can play with on-screen buttons (no keys).",14,(200,200,215))

        if paused:
            p=pygame.Rect(W//2-170,H//2-120,340,240)
            pygame.draw.rect(screen,(20,20,30),p,border_radius=16)
            pygame.draw.rect(screen,(160,160,210),p,2,border_radius=16)
            label(screen,p.x+120,p.y+20,"PAUSED",20,(255,230,160))
            if button(screen,(p.x+30,p.y+70,280,44),"CONTINUE",mouse,click): paused=False
            if button(screen,(p.x+30,p.y+130,280,44),"EXIT",mouse,click): running=False

        pygame.display.flip()

    pygame.quit()

# ---------- CLI ----------
def main():
    ap=argparse.ArgumentParser()
    ap.add_argument("--editor", type=str, default=None)
    ap.add_argument("--game", type=str, default=None)
    a=ap.parse_args()
    if a.editor: run_editor(a.editor)
    elif a.game: run_game(a.game)
    else:
        print("python ragnarengine.py --editor <project>\npython ragnarengine.py --game <project>")

if __name__=="__main__":
    main()

